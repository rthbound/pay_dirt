{"name":"PayDirt","tagline":"Reduce towering codebases to modular rubble (or more Ruby gems)","body":"## pay_dirt [![Gem Version](https://badge.fury.io/rb/pay_dirt.png)](http://badge.fury.io/rb/pay_dirt) [![Build Status](https://travis-ci.org/rthbound/pay_dirt.png?branch=master)](https://travis-ci.org/rthbound/pay_dirt) [![Coverage Status](https://coveralls.io/repos/rthbound/pay_dirt/badge.png?branch=master)](https://coveralls.io/r/rthbound/pay_dirt?branch=master) [![Code Climate](https://codeclimate.com/github/rthbound/pay_dirt.png)](https://codeclimate.com/github/rthbound/pay_dirt)\r\n\r\nProvides the basic building blocks of a pattern capable of reducing a towering codebase to modular rubble (or more Ruby gems)\r\n\r\n### What is PayDirt\r\n\r\nPayDirt gets its name from an 18th century gold mining idiom. One was said to have \"struck pay dirt\" when his pick axe revealed a vein of ore.\r\nI hit pay dirt when I discovered this pattern. It provides me the freedom to build quickly with the confidence of knowing that testing will be a breeze.\r\n\r\n### What is the use case?\r\n\r\nIts use case is gem making. It's for getting rid of callbacks and for shipping business logic off to the more suitable (and more portable) location.\r\nIt's for packaging use cases up in a modular fashion, where each unit expects to be provided certain dependencies and can be called to provide an expected result.\r\nIt makes sure you're using dependency injection so you can painlessly mock all your dependencies.\r\n\r\nThe basic idea:\r\n\r\n1. Initialize an object by supplying ALL dependencies as a single options hash.\r\n2. The object should have ONE public method, `#call`, which will return an expected result object.\r\n\r\nWhat pay_dirt does to help:\r\n\r\n1. It will set instance variables from the hash of dependencies, using top level key-value pairs.\r\n2. It will not initialize (it WILL error) without all required dependencies.\r\n3. It allows you to set default values for any dependencies (just merge the `options` argument into your defaults hash before calling `#load_options`)\r\n\r\nPayDirt also provides a `PayDirt::Result` object for your service objects to return (it will respond to `#successful?` and `#data`, see some examples). This is entirely optional, as this object can return whatever you like.\r\n\r\n### Getting on to it\r\n\r\nThere are two ways to employ the pattern:\r\n\r\n1. use a class that inherits from [PayDirt::Base](https://github.com/rthbound/pay_dirt/blob/master/test/unit/pay_dirt/base_test.rb#L6-L24)\r\n2. use a class or module that includes [PayDirt::UseCase](https://github.com/rthbound/pay_dirt/blob/master/test/unit/pay_dirt/use_case_test.rb#L6-L26)\r\n\r\nservice object generator\r\n------------------------\r\npay_dirt now provides a service object generator,\r\npowered by [thor](https://github.com/erikhuda/thor).\r\nIn order to use them in your rails app, you'll need to install the task. Here's how:\r\n\r\n```\r\n$ thor install https://raw.github.com/rthbound/pay_dirt/master/pay_dirt.thor\r\n...\r\nDo you wish to continue [y/N]? y\r\nPlease specify a name for https://raw.github.com/rthbound/pay_dirt/master/pay_dirt.thor in the system repository [pay_dirt.thor]: pay_dirt\r\nStoring thor file in your system repository\r\n$\r\n```\r\n\r\nAfter installing, you can use your new generator *anywhere* you can use thor. It'll tell you **how it's used**:\r\n\r\n```\r\n$ thor help pay_dirt:service_object:new\r\nUsage:\r\n  thor pay_dirt:service_object:new FILE -d, --dependencies=one two three\r\n\r\nOptions:\r\n  -d, --dependencies=one two three  # specify required dependencies\r\n  -D, [--defaults=key:value]        # specify default dependencies\r\n  -i, [--inherit]                   # inherit from PayDirt::Base class\r\n                                    # Default: true\r\n  -m, [--include]                   # include the PayDirt::UseCase module (overrides --inherit)\r\n\r\ncreate a service object\r\n```\r\n\r\nexample\r\n-------\r\n```\r\n$ thor pay_dirt:service_object:new quick/digit_check -d fingers toes nose -D fingers:10 toes:10\r\n      create  lib/quick/digit_check.rb\r\n      create  test/unit/quick/digit_check_test.rb\r\n      append  test/minitest_helper.rb\r\n```\r\n\r\nRunning the above generator will create the following object\r\n\r\n```ruby\r\nrequire 'pay_dirt'\r\n\r\nmodule Quick\r\n  class DigitCheck < PayDirt::Base\r\n    def initialize(options = {})\r\n      options = {\r\n        fingers: 10,\r\n        toes: 10,\r\n      }.merge(options)\r\n\r\n      load_options(:fingers, :toes, :nose, options)\r\n    end\r\n\r\n    def call\r\n      return result(true)\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nand the following unit test\r\n```ruby\r\nrequire 'minitest_helper'\r\n\r\ndescribe Quick::DigitCheck do\r\n  before do\r\n    @subject = Quick::DigitCheck\r\n    @params = {\r\n      fingers: MiniTest::Mock.new,\r\n      toes: MiniTest::Mock.new,\r\n      nose: MiniTest::Mock.new,\r\n    }\r\n  end\r\n\r\n  describe \"as a class\" do\r\n    it \"initializes properly\" do\r\n      @subject.new(@params).must_respond_to :call\r\n    end\r\n\r\n    it \"errors when initialized without required dependencies\" do\r\n      -> { @subject.new(@params.reject { |k| k.to_s == 'nose' }) }.must_raise RuntimeError\r\n    end\r\n  end\r\n\r\n  describe \"as an instance\" do\r\n    it \"executes successfully\" do\r\n      result = @subject.new(@params).call\r\n      result.successful?.must_equal true\r\n      result.must_be_kind_of PayDirt::Result\r\n    end\r\n  end\r\nend\r\n```\r\n\r\n### Usage:\r\nThe class generated can be used in the following manner:\r\n```ruby\r\nrequire \"quick/digit_check\"  #=> true\r\nQuick::DigitCheck.new(nose: true).call\r\n #=> #<PayDirt::Result:0xa0be85c @data=nil, @success=true>\r\n```\r\nAs you can see, we can now call `Quick::DigitCheck.new(nose: true).call`\r\nand expect a successful return object. Where you take it from there is up to you.\r\n\r\nmore examples\r\n-------------\r\n1. [rubeuler](https://github.com/rthbound/rubeuler)\r\n2. [protected_record](https://github.com/rthbound/protected_record)\r\n3. [konamio](https://github.com/rthbound/konamio)\r\n4. [eenie_meenie](https://github.com/rthbound/eenie_meenie)\r\n5. [foaas](https://github.com/rthbound/foaas)\r\n6. [konami-fo](https://github.com/rthbound/konami-fo)\r\n7. [rungs](https://github.com/rthbound/rungs)\r\n\r\n#### PayDirt is a Ruby gem based on the \"use case\" pattern set forth in [opencurriculum-flashcards](https://github.com/isotope11/opencurriculum-flashcards)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}